#!/bin/bash

# =============================================================================
# Claude Config Switcher (CCS) - Claude API 配置管理工具
# 
# 功能：
# - 管理多个 Claude API 配置
# - 美观的交互式界面
# - 支持添加、删除、修改、切换配置
# - 兼容 Linux 和 Mac
# - 集成 Claude Code 设置文件生成
#
# 使用方法：
# - `ccs`                : 显示交互式菜单
# - `ccs <名称>`         : 直接切换到指定配置  
# - `ccs <数字>`         : 切换到列表中第N个配置
# - `ccs add`           : 添加新配置
# - `ccs delete`        : 删除配置
# - `ccs edit`          : 编辑配置
# - `ccs list`          : 列出所有配置
# - `ccs help`          : 显示帮助信息
# =============================================================================

set -euo pipefail

# --- 全局变量 ---
SCRIPT_NAME="Claude Config Switcher"
VERSION="1.0.0"
CLAUDE_DIR="${HOME}/.claude"
KEYS_FILE="${CLAUDE_DIR}/keys.conf"
SETTINGS_FILE="${CLAUDE_DIR}/settings.json"
CURRENT_FILE="${CLAUDE_DIR}/current"
TEMPLATE_FILE="${CLAUDE_DIR}/template.json"
VERSION_CACHE="${CLAUDE_DIR}/.version_cache"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[0;37m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# 图标定义
ICON_SUCCESS="✅"
ICON_ERROR="❌"
ICON_WARNING="⚠️"
ICON_INFO="ℹ️"
ICON_ARROW="➤"
ICON_BULLET="•"
ICON_CONFIG="🔧"
ICON_CLAUDE="🤖"

# GitHub用户信息
GITHUB_USER="zhiqing0205"
REPO_URL="https://github.com/${GITHUB_USER}/ClaudeCodeSwitchConfig"

# =============================================================================
# 辅助函数
# =============================================================================

# 打印彩色消息
print_color() {
    local color="$1"
    local message="$2"
    printf "${color}%s${NC}\n" "$message"
}

# 打印标题
print_title() {
    local title="$1"
    echo
    print_color "$BOLD$CYAN" "╔══════════════════════════════════════════════════════════════════════════════╗"
    printf "${BOLD}${CYAN}║${NC}${BOLD}%-78s${CYAN}║${NC}\n" "  $ICON_CLAUDE $SCRIPT_NAME $VERSION - $title"
    print_color "$BOLD$CYAN" "╚══════════════════════════════════════════════════════════════════════════════╝"
    echo
}

# 打印分割线
print_separator() {
    print_color "$CYAN" "────────────────────────────────────────────────────────────────────────────────"
}

# 成功消息
print_success() {
    print_color "$GREEN" "$ICON_SUCCESS $1"
}

# 错误消息
print_error() {
    print_color "$RED" "$ICON_ERROR $1" >&2
}

# 警告消息
print_warning() {
    print_color "$YELLOW" "$ICON_WARNING $1"
}

# 信息消息
print_info() {
    print_color "$BLUE" "$ICON_INFO $1"
}

# 从配置文件获取值
get_config_value() {
    local file="$1"
    local section="$2"
    local key="$3"
    
    awk -v section="$section" -v key="$key" '
        $0 == "[" section "]" { in_section = 1; next }
        in_section && /^\s*\[.*\]\s*$/ { in_section = 0; exit }
        in_section {
            if (index($0, key " =") == 1 || index($0, key "=") == 1) {
                split($0, parts, "=")
                if (length(parts) > 1) {
                    value = parts[2]
                    for (i = 3; i <= length(parts); i++) {
                        value = value "=" parts[i]
                    }
                    sub(/^[ \t]*/, "", value)
                    sub(/[ \t]*$/, "", value)
                    print value
                    exit
                }
            }
        }
    ' "$file"
}

# 获取所有配置名称
get_all_configs() {
    if [[ ! -f "$KEYS_FILE" ]]; then
        return 0
    fi
    awk '/^\[.*\]$/ { gsub(/[\[\]]/, "", $0); print }' "$KEYS_FILE"
}

# 获取当前激活的配置
get_current_config() {
    if [[ -f "$CURRENT_FILE" ]]; then
        cat "$CURRENT_FILE"
    fi
}

# 检查配置是否存在
config_exists() {
    local config_name="$1"
    grep -q "^\[$config_name\]$" "$KEYS_FILE" 2>/dev/null
}

# 初始化Claude目录
init_claude_dir() {
    if [[ ! -d "$CLAUDE_DIR" ]]; then
        print_info "创建 Claude 配置目录: $CLAUDE_DIR"
        if ! mkdir -p "$CLAUDE_DIR" || ! chmod 700 "$CLAUDE_DIR"; then
            print_error "无法创建或设置目录权限: $CLAUDE_DIR"
            return 1
        fi
    fi
    
    if [[ ! -f "$KEYS_FILE" ]]; then
        touch "$KEYS_FILE"
        chmod 600 "$KEYS_FILE"
    fi
    
    return 0
}

# 要同步的文件列表
UPDATE_FILES=("ccs" "setup.sh" "install-online.sh")

# 检查更新
check_for_updates() {
    # 静默模式，避免干扰用户体验
    local should_check=true
    
    # 检查是否有网络和必要工具
    if ! command -v curl >/dev/null 2>&1; then
        return 0
    fi
    
    # 检查缓存，避免频繁检查（每6小时检查一次）
    if [[ -f "$VERSION_CACHE" ]]; then
        local last_check
        last_check=$(stat -c %Y "$VERSION_CACHE" 2>/dev/null || echo 0)
        local current_time
        current_time=$(date +%s)
        local time_diff=$((current_time - last_check))
        
        # 6小时 = 21600秒
        if [[ $time_diff -lt 21600 ]]; then
            return 0
        fi
    fi
    
    # 检查MD5工具
    local md5_cmd
    if command -v md5sum >/dev/null 2>&1; then
        md5_cmd="md5sum"
    elif command -v md5 >/dev/null 2>&1; then
        md5_cmd="md5 -q"
    else
        return 0
    fi
    
    # 检查所有文件是否有更新
    local has_update=false
    local updated_files=()
    
    for file in "${UPDATE_FILES[@]}"; do
        # 跳过不存在的本地文件（可能是新文件）
        if [[ ! -f "$file" ]]; then
            has_update=true
            updated_files+=("$file [新文件]")
            continue
        fi
        
        # 获取本地文件MD5
        local local_md5
        if [[ "$md5_cmd" == "md5sum" ]]; then
            local_md5=$($md5_cmd "$file" 2>/dev/null | cut -d' ' -f1)
        else
            local_md5=$($md5_cmd "$file" 2>/dev/null)
        fi
        
        # 获取远程文件MD5
        local remote_content
        remote_content=$(curl -fsSL --connect-timeout 5 --max-time 10 "$REPO_URL/raw/main/$file" 2>/dev/null)
        
        if [[ $? -eq 0 && -n "$remote_content" ]]; then
            local remote_md5
            if [[ "$md5_cmd" == "md5sum" ]]; then
                remote_md5=$(echo "$remote_content" | $md5_cmd | cut -d' ' -f1)
            else
                remote_md5=$(echo "$remote_content" | $md5_cmd)
            fi
            
            # 比较MD5
            if [[ -n "$remote_md5" && "$local_md5" != "$remote_md5" ]]; then
                has_update=true
                updated_files+=("$file")
            fi
        fi
    done
    
    # 更新检查缓存
    date +%s > "$VERSION_CACHE"
    
    # 如果有更新，提示用户
    if [[ "$has_update" == true ]]; then
        echo
        print_warning "检测到以下文件有新版本可用："
        for file in "${updated_files[@]}"; do
            echo "  - $file"
        done
        echo
        read -rp "$(print_color "$BOLD$WHITE" "是否立即更新? (Y/n): ")" update_confirm
        
        if [[ ! "$update_confirm" =~ ^[Nn]$ ]]; then
            # 调用强制更新函数
            force_update "--auto"
        else
            print_info "已跳过更新，下次启动时会再次检查"
        fi
        echo
    fi
}

# 强制更新
force_update() {
    local is_auto="${1:-}"
    
    if [[ "$is_auto" != "--auto" ]]; then
        print_title "手动更新 CCS"
    fi
    
    # 检查必要工具
    if ! command -v curl >/dev/null 2>&1; then
        print_error "需要 curl 工具来下载更新"
        return 1
    fi
    
    print_info "正在检查远程版本..."
    
    # 检查MD5工具
    local md5_cmd
    if command -v md5sum >/dev/null 2>&1; then
        md5_cmd="md5sum"
    elif command -v md5 >/dev/null 2>&1; then
        md5_cmd="md5 -q"
    else
        print_error "无法计算文件MD5，请安装 md5sum 或 md5 工具"
        return 1
    fi
    
    # 创建备份目录
    local backup_dir=".ccs_backup_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"
    
    # 统计需要更新的文件
    local updated_files=()
    local failed_files=()
    local new_files=()
    
    for file in "${UPDATE_FILES[@]}"; do
        print_info "检查文件: $file"
        
        # 获取远程文件
        local remote_content
        remote_content=$(curl -fsSL --connect-timeout 10 --max-time 30 "$REPO_URL/raw/main/$file" 2>/dev/null)
        
        if [[ $? -ne 0 || -z "$remote_content" ]]; then
            print_warning "无法下载: $file"
            failed_files+=("$file")
            continue
        fi
        
        # 如果本地文件不存在，标记为新文件
        if [[ ! -f "$file" ]]; then
            new_files+=("$file")
            echo "$remote_content" > "$file"
            chmod +x "$file"
            print_success "新增文件: $file"
            continue
        fi
        
        # 计算MD5比较
        local local_md5 remote_md5
        if [[ "$md5_cmd" == "md5sum" ]]; then
            local_md5=$($md5_cmd "$file" 2>/dev/null | cut -d' ' -f1)
            remote_md5=$(echo "$remote_content" | $md5_cmd | cut -d' ' -f1)
        else
            local_md5=$($md5_cmd "$file" 2>/dev/null)
            remote_md5=$(echo "$remote_content" | $md5_cmd)
        fi
        
        # 如果MD5不同，更新文件
        if [[ "$local_md5" != "$remote_md5" ]]; then
            # 备份原文件
            cp "$file" "$backup_dir/$file.backup"
            
            # 更新文件
            echo "$remote_content" > "$file"
            chmod +x "$file"
            
            updated_files+=("$file")
            print_success "已更新: $file"
        else
            print_info "已是最新: $file"
        fi
    done
    
    echo
    
    # 显示更新结果
    if [[ ${#updated_files[@]} -gt 0 || ${#new_files[@]} -gt 0 ]]; then
        print_success "更新完成！"
        
        if [[ ${#updated_files[@]} -gt 0 ]]; then
            print_info "更新的文件 (${#updated_files[@]}):"
            for file in "${updated_files[@]}"; do
                echo "  - $file"
            done
        fi
        
        if [[ ${#new_files[@]} -gt 0 ]]; then
            print_info "新增的文件 (${#new_files[@]}):"
            for file in "${new_files[@]}"; do
                echo "  - $file"
            done
        fi
        
        print_info "备份目录: $backup_dir"
        
        # 更新版本缓存
        date +%s > "$VERSION_CACHE"
        
        # 如果更新了ccs脚本本身，重新启动
        if [[ " ${updated_files[@]} " =~ " ccs " ]]; then
            echo
            print_info "CCS 脚本已更新，正在重新启动..."
            echo
            exec "$0" "${@:2}"
        fi
    else
        if [[ ${#failed_files[@]} -gt 0 ]]; then
            print_warning "部分文件更新失败:"
            for file in "${failed_files[@]}"; do
                echo "  - $file"
            done
        else
            print_success "所有文件都已是最新版本！"
        fi
        
        # 清理空的备份目录
        rmdir "$backup_dir" 2>/dev/null
    fi
    
    return 0
}

# 创建默认模板文件
create_default_template() {
    if [[ ! -f "$TEMPLATE_FILE" ]]; then
        cat > "$TEMPLATE_FILE" << 'EOF'
{
  "env": {
    "ANTHROPIC_API_KEY": "{{API_KEY}}",
    "ANTHROPIC_BASE_URL": "{{BASE_URL}}",
    "CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC": 1
  },
  "permissions": {
    "allow": [
      "Bash(*)",
      "LS(*)",
      "Read(*)",
      "Write(*)",
      "Edit(*)",
      "MultiEdit(*)",
      "Glob(*)",
      "Grep(*)",
      "Task(*)",
      "WebFetch(*)",
      "WebSearch(*)",
      "TodoWrite(*)",
      "NotebookRead(*)",
      "NotebookEdit(*)"
    ],
    "deny": []
  },
  "apiKeyHelper": "echo '{{API_KEY}}'"
}
EOF
        print_info "已创建默认模板文件: $TEMPLATE_FILE"
    fi
}

# 生成settings.json文件
generate_settings() {
    local config_name="$1"
    local api_key base_url
    api_key=$(get_config_value "$KEYS_FILE" "$config_name" "apiKey")
    base_url=$(get_config_value "$KEYS_FILE" "$config_name" "baseUrl")

    if [[ -z "$api_key" ]]; then
        print_error "在配置 '$config_name' 中未找到 'apiKey'"
        return 1
    fi
    if [[ -z "$base_url" ]]; then
        print_error "在配置 '$config_name' 中未找到 'baseUrl'"
        return 1
    fi

    # 确保模板文件存在
    create_default_template

    # 使用模板生成settings.json
    if [[ -f "$TEMPLATE_FILE" ]]; then
        # 读取模板并替换变量
        local template_content
        template_content=$(cat "$TEMPLATE_FILE")
        
        # 替换模板变量
        template_content="${template_content//\{\{API_KEY\}\}/$api_key}"
        template_content="${template_content//\{\{BASE_URL\}\}/$base_url}"
        template_content="${template_content//\{\{CONFIG_NAME\}\}/$config_name}"
        
        # 写入settings.json
        echo "$template_content" > "$SETTINGS_FILE"
    else
        print_error "模板文件不存在: $TEMPLATE_FILE"
        return 1
    fi

    if [[ $? -eq 0 ]]; then
        print_success "成功切换到配置: '$config_name'"
        print_info "API 密钥: ...${api_key: -4}"
        print_info "Base URL: $base_url"
        return 0
    else
        print_error "写入 settings.json 失败"
        return 1
    fi
}

# =============================================================================
# 核心功能函数
# =============================================================================

# 列出所有配置
list_configs() {
    local configs
    mapfile -t configs < <(get_all_configs)
    local current_config
    current_config=$(get_current_config)
    
    if [[ ${#configs[@]} -eq 0 ]]; then
        print_warning "未找到任何 Claude API 配置"
        print_info "使用 'ccs add' 来添加第一个配置"
        return 0
    fi
    
    print_title "Claude API 配置列表"
    
    local i=1
    for config in "${configs[@]}"; do
        local status=""
        if [[ "$config" == "$current_config" ]]; then
            status=" ${GREEN}${BOLD}[当前]${NC}"
        fi
        
        # 获取配置信息
        local base_url api_key
        base_url=$(get_config_value "$KEYS_FILE" "$config" "baseUrl")
        api_key=$(get_config_value "$KEYS_FILE" "$config" "apiKey")
        
        if [[ -n "$api_key" ]]; then
            api_key="...${api_key: -4}"
        else
            api_key="未设置"
        fi
        
        echo -e "${BOLD}${WHITE}$(printf '%2d.' "$i")${NC} ${CYAN}$(printf '%-20s' "$config")${NC}${status}"
        echo -e "    ${BLUE}Base URL:${NC} ${base_url:-未设置}"
        echo -e "    ${BLUE}API Key:${NC}  $api_key"
        echo
        i=$((i + 1))
    done
}

# 添加新配置
add_config() {
    print_title "添加新的 Claude API 配置"
    
    local config_name base_url api_key
    
    while true; do
        read -rp "$(print_color "$BOLD$WHITE" "配置名称 (例如: MyAPI): ")" config_name
        if [[ -z "$config_name" ]]; then
            print_error "配置名称不能为空"
            continue
        fi
        
        if config_exists "$config_name"; then
            print_error "配置 '$config_name' 已存在"
            continue
        fi
        
        # 验证配置名称格式
        if [[ ! "$config_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            print_error "配置名称只能包含字母、数字、下划线和横线"
            continue
        fi
        
        break
    done
    
    while true; do
        read -rp "$(print_color "$BOLD$WHITE" "Base URL: ")" base_url
        if [[ -z "$base_url" ]]; then
            print_error "Base URL 不能为空"
            continue
        fi
        break
    done
    
    while true; do
        read -rp "$(print_color "$BOLD$WHITE" "API Key: ")" api_key
        if [[ -z "$api_key" ]]; then
            print_error "API Key 不能为空"
            continue
        fi
        break
    done
    
    # 添加到配置文件
    {
        echo ""
        echo "[$config_name]"
        echo "baseUrl = $base_url"
        echo "apiKey = $api_key"
    } >> "$KEYS_FILE"
    
    print_success "配置 '$config_name' 添加成功！"
}

# 删除配置
delete_config() {
    print_title "删除 Claude API 配置"
    
    local configs
    mapfile -t configs < <(get_all_configs)
    
    if [[ ${#configs[@]} -eq 0 ]]; then
        print_warning "没有可删除的配置"
        return 0
    fi
    
    list_configs
    
    local selection
    read -rp "$(print_color "$BOLD$RED" "请选择要删除的配置 (输入数字或名称): ")" selection
    
    local config_to_delete=""
    
    # 检查是否为数字
    if [[ "$selection" =~ ^[0-9]+$ ]]; then
        if [[ "$selection" -ge 1 && "$selection" -le ${#configs[@]} ]]; then
            config_to_delete="${configs[$((selection - 1))]}"
        else
            print_error "无效的数字选择: $selection"
            return 1
        fi
    else
        if config_exists "$selection"; then
            config_to_delete="$selection"
        else
            print_error "配置 '$selection' 不存在"
            return 1
        fi
    fi
    
    # 确认删除
    print_warning "即将删除配置: $config_to_delete"
    read -rp "$(print_color "$RED" "确认删除? (y/N): ")" confirm
    
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        # 使用临时文件删除配置
        local temp_file
        temp_file=$(mktemp)
        awk -v config="$config_to_delete" '
            /^\[.*\]$/ {
                section = $0
                gsub(/[\[\]]/, "", section)
                if (section == config) {
                    skip = 1
                } else {
                    skip = 0
                    print $0
                }
                next
            }
            !skip { print $0 }
        ' "$KEYS_FILE" > "$temp_file"
        
        mv "$temp_file" "$KEYS_FILE"
        
        # 如果删除的是当前配置，清除当前配置记录
        local current_config
        current_config=$(get_current_config)
        if [[ "$current_config" == "$config_to_delete" ]]; then
            rm -f "$CURRENT_FILE"
            rm -f "$SETTINGS_FILE"
            print_warning "已清除当前配置记录和 settings.json"
        fi
        
        print_success "配置 '$config_to_delete' 删除成功！"
    else
        print_info "删除操作已取消"
    fi
}

# 编辑配置
edit_config() {
    print_title "编辑 Claude API 配置"
    
    local configs
    mapfile -t configs < <(get_all_configs)
    
    if [[ ${#configs[@]} -eq 0 ]]; then
        print_warning "没有可编辑的配置"
        return 0
    fi
    
    list_configs
    
    local selection
    read -rp "$(print_color "$BOLD$YELLOW" "请选择要编辑的配置 (输入数字或名称): ")" selection
    
    local config_to_edit=""
    
    if [[ "$selection" =~ ^[0-9]+$ ]]; then
        if [[ "$selection" -ge 1 && "$selection" -le ${#configs[@]} ]]; then
            config_to_edit="${configs[$((selection - 1))]}"
        else
            print_error "无效的数字选择: $selection"
            return 1
        fi
    else
        if config_exists "$selection"; then
            config_to_edit="$selection"
        else
            print_error "配置 '$selection' 不存在"
            return 1
        fi
    fi
    
    # 获取当前配置值
    local current_base_url current_api_key
    current_base_url=$(get_config_value "$KEYS_FILE" "$config_to_edit" "baseUrl")
    current_api_key=$(get_config_value "$KEYS_FILE" "$config_to_edit" "apiKey")
    
    print_separator
    print_info "当前配置 '$config_to_edit' 的内容:"
    echo "  配置名称: $config_to_edit"
    echo "  Base URL: $current_base_url"
    echo "  API Key:  ...${current_api_key: -4}"
    echo
    
    local new_config_name new_base_url new_api_key
    read -rp "$(print_color "$BOLD$WHITE" "新的配置名称 (回车保持不变): ")" new_config_name
    read -rp "$(print_color "$BOLD$WHITE" "新的 Base URL (回车保持不变): ")" new_base_url
    read -rp "$(print_color "$BOLD$WHITE" "新的 API Key (回车保持不变): ")" new_api_key
    
    # 如果用户没输入，保持原值
    if [[ -z "$new_config_name" ]]; then
        new_config_name="$config_to_edit"
    fi
    if [[ -z "$new_base_url" ]]; then
        new_base_url="$current_base_url"
    fi
    if [[ -z "$new_api_key" ]]; then
        new_api_key="$current_api_key"
    fi
    
    # 检查新配置名称是否与现有配置重复（但不是自己）
    if [[ "$new_config_name" != "$config_to_edit" ]] && config_exists "$new_config_name"; then
        print_error "配置名称 '$new_config_name' 已存在，请选择其他名称"
        return 1
    fi
    
    # 验证配置名称格式
    if [[ ! "$new_config_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "配置名称只能包含字母、数字、下划线和连字符"
        return 1
    fi
    
    # 使用临时文件替换配置
    local temp_file
    temp_file=$(mktemp)
    
    awk -v config="$config_to_edit" -v new_config="$new_config_name" -v new_base_url="$new_base_url" -v new_api_key="$new_api_key" '
        /^\[.*\]$/ {
            section = $0
            gsub(/[\[\]]/, "", section)
            if (section == config) {
                print "["new_config"]"
                print "baseUrl = " new_base_url
                print "apiKey = " new_api_key
                skip = 1
            } else {
                skip = 0
                print $0
            }
            next
        }
        skip && /^\s*\[.*\]\s*$/ { skip = 0 }
        !skip { print $0 }
    ' "$KEYS_FILE" > "$temp_file"
    
    mv "$temp_file" "$KEYS_FILE"
    
    # 如果修改的是当前配置，需要更新current文件
    local current_config
    current_config=$(get_current_config)
    if [[ "$current_config" == "$config_to_edit" ]]; then
        echo "$new_config_name" > "$CURRENT_FILE"
        # 重新生成settings.json
        generate_settings "$new_config_name"
        print_info "已更新当前配置为 '$new_config_name'"
    fi
    
    # 显示修改结果
    if [[ "$new_config_name" != "$config_to_edit" ]]; then
        print_success "配置 '$config_to_edit' 已重命名为 '$new_config_name' 并更新成功！"
    else
        print_success "配置 '$config_to_edit' 编辑成功！"
    fi
}

# 编辑模板
edit_template() {
    print_title "编辑 settings.json 模板"
    
    # 确保模板文件存在
    create_default_template
    
    print_info "当前模板文件位置: $TEMPLATE_FILE"
    print_info "模板支持以下变量:"
    echo "  {{API_KEY}}     - 当前配置的 API Key"
    echo "  {{BASE_URL}}    - 当前配置的 Base URL"  
    echo "  {{CONFIG_NAME}} - 当前配置的名称"
    echo
    
    print_warning "请确保 JSON 格式正确，否则可能导致配置生成失败"
    echo
    
    # 检测可用的编辑器
    local available_editors=()
    local editor_names=()
    
    # 优先使用环境变量 EDITOR 指定的编辑器
    if [[ -n "${EDITOR:-}" ]] && command -v "$EDITOR" >/dev/null 2>&1; then
        available_editors+=("$EDITOR")
        editor_names+=("$EDITOR (系统默认编辑器)")
    fi
    
    # 添加其他常见编辑器（避免重复）
    local common_editors=("nano" "vim" "vi" "code" "emacs" "gedit")
    local common_names=("Nano (易用的文本编辑器)" "Vim (高级文本编辑器)" "Vi (经典文本编辑器)" "VS Code (图形界面编辑器)" "Emacs (功能强大的编辑器)" "Gedit (GNOME文本编辑器)")
    
    for i in "${!common_editors[@]}"; do
        local cmd="${common_editors[$i]}"
        if command -v "$cmd" >/dev/null 2>&1; then
            # 检查是否已经添加过（避免重复）
            local already_added=false
            for existing in "${available_editors[@]}"; do
                if [[ "$existing" == "$cmd" ]]; then
                    already_added=true
                    break
                fi
            done
            
            if [[ "$already_added" == "false" ]]; then
                available_editors+=("$cmd")
                editor_names+=("${common_names[$i]}")
            fi
        fi
    done
    
    if [[ ${#available_editors[@]} -eq 0 ]]; then
        print_error "未找到可用的编辑器"
        print_info "请安装以下任意一个编辑器: nano, vim, vi, code, emacs, gedit"
        return 1
    fi
    
    # 显示可用编辑器列表
    print_separator
    print_info "检测到以下可用编辑器:"
    for i in "${!available_editors[@]}"; do
        echo -e "${BOLD}${WHITE}$((i + 1)).${NC} ${CYAN}${editor_names[$i]}${NC}"
    done
    echo
    
    # 让用户选择编辑器
    local editor=""
    while true; do
        read -rp "$(print_color "$BOLD$WHITE" "请选择编辑器 (输入数字), 或输入 'c' 取消: ")" choice
        
        if [[ "$choice" =~ ^[Cc]$ ]]; then
            print_info "已取消模板编辑"
            return 0
        elif [[ "$choice" =~ ^[0-9]+$ ]] && [[ "$choice" -ge 1 && "$choice" -le ${#available_editors[@]} ]]; then
            editor="${available_editors[$((choice - 1))]}"
            break
        else
            print_error "无效选择，请输入 1-${#available_editors[@]} 或 'c'"
        fi
    done
    
    print_info "将使用 ${editor} 编辑模板..."
    
    # 备份原模板
    local backup_file="${TEMPLATE_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
    cp "$TEMPLATE_FILE" "$backup_file"
    print_info "已创建模板备份: $backup_file"
    
    # 启动编辑器
    local edit_success=false
    case "$editor" in
        "code")
            # VS Code 需要等待用户完成编辑
            print_info "正在启动 VS Code，请编辑完成后关闭文件..."
            if "$editor" --wait "$TEMPLATE_FILE"; then
                edit_success=true
            fi
            ;;
        "gedit")
            # Gedit 图形编辑器
            print_info "正在启动 Gedit..."
            if "$editor" "$TEMPLATE_FILE"; then
                edit_success=true
            fi
            ;;
        "emacs")
            # Emacs 编辑器
            print_info "正在启动 Emacs (使用 Ctrl+X Ctrl+C 退出)..."
            if "$editor" "$TEMPLATE_FILE"; then
                edit_success=true
            fi
            ;;
        "vim")
            # Vim 编辑器
            print_info "正在启动 Vim (使用 :wq 保存并退出)..."
            if "$editor" "$TEMPLATE_FILE"; then
                edit_success=true
            fi
            ;;
        "vi")
            # Vi 编辑器  
            print_info "正在启动 Vi (使用 :wq 保存并退出)..."
            if "$editor" "$TEMPLATE_FILE"; then
                edit_success=true
            fi
            ;;
        "nano")
            # Nano 编辑器
            print_info "正在启动 Nano (使用 Ctrl+X 退出)..."
            if "$editor" "$TEMPLATE_FILE"; then
                edit_success=true
            fi
            ;;
        *)
            # 其他编辑器的默认处理
            print_info "正在启动 $editor..."
            if "$editor" "$TEMPLATE_FILE"; then
                edit_success=true
            fi
            ;;
    esac
    
    if [[ "$edit_success" == "true" ]]; then
        # 验证 JSON 格式
        if command -v python3 >/dev/null 2>&1; then
            if python3 -m json.tool "$TEMPLATE_FILE" >/dev/null 2>&1; then
                print_success "模板编辑成功，JSON 格式验证通过！"
            else
                print_error "JSON 格式验证失败！"
                read -rp "是否恢复备份? (Y/n): " restore
                if [[ ! "$restore" =~ ^[Nn]$ ]]; then
                    cp "$backup_file" "$TEMPLATE_FILE"
                    print_info "已恢复原模板"
                fi
            fi
        else
            print_success "模板编辑完成（未进行格式验证）"
        fi
    else
        print_error "编辑器退出异常"
    fi
}

# 切换配置
switch_config() {
    local target_config="$1"
    
    if ! config_exists "$target_config"; then
        print_error "配置 '$target_config' 不存在"
        return 1
    fi
    
    # 生成settings.json并保存当前配置名称
    if generate_settings "$target_config"; then
        echo "$target_config" > "$CURRENT_FILE"
        return 0
    else
        return 1
    fi
}

# 交互式菜单
interactive_menu() {
    while true; do
        clear
        print_title "配置管理主菜单"
        
        local current_config
        current_config=$(get_current_config)
        if [[ -n "$current_config" ]]; then
            print_color "$GREEN" "$ICON_CONFIG 当前配置: $current_config"
            echo
        fi
        
        list_configs
        
        print_separator
        printf "${BOLD}${WHITE}操作选项:${NC}\n"
        printf "${CYAN}[1-9]${NC}     切换到对应编号的配置\n"
        printf "${CYAN}[a]dd${NC}     添加新配置\n"
        printf "${CYAN}[d]elete${NC}  删除配置\n"
        printf "${CYAN}[e]dit${NC}    编辑配置\n"
        printf "${CYAN}[t]emplate${NC} 编辑 settings.json 模板\n"
        printf "${CYAN}[l]ist${NC}    刷新配置列表\n"
        printf "${CYAN}[h]elp${NC}    显示帮助信息\n"
        printf "${CYAN}[q]uit${NC}    退出程序\n"
        print_separator
        
        local choice
        read -rp "$(print_color "$BOLD$WHITE" "请选择操作: ")" choice
        
        case "$choice" in
            [1-9])
                local configs
                mapfile -t configs < <(get_all_configs)
                if [[ "$choice" -le ${#configs[@]} ]]; then
                    switch_config "${configs[$((choice - 1))]}"
                    read -rp "$(print_color "$CYAN" "按 Enter 键继续...")"
                else
                    print_error "无效的配置编号"
                    read -rp "$(print_color "$CYAN" "按 Enter 键继续...")"
                fi
                ;;
            a|add)
                add_config
                read -rp "$(print_color "$CYAN" "按 Enter 键继续...")"
                ;;
            d|delete)
                delete_config
                read -rp "$(print_color "$CYAN" "按 Enter 键继续...")"
                ;;
            e|edit)
                edit_config
                read -rp "$(print_color "$CYAN" "按 Enter 键继续...")"
                ;;
            t|template)
                edit_template
                read -rp "$(print_color "$CYAN" "按 Enter 键继续...")"
                ;;
            l|list)
                continue
                ;;
            h|help)
                show_help
                read -rp "$(print_color "$CYAN" "按 Enter 键继续...")"
                ;;
            q|quit)
                print_info "感谢使用 Claude Config Switcher！"
                exit 0
                ;;
            *)
                print_error "无效的选择: $choice"
                read -rp "$(print_color "$CYAN" "按 Enter 键继续...")"
                ;;
        esac
    done
}

# 显示帮助信息
show_help() {
    clear
    print_title "帮助信息"
    
    cat << EOF
${BOLD}用法:${NC}
  ccs                        显示交互式菜单
  ccs <配置名>               直接切换到指定配置
  ccs <数字>                 切换到列表中第N个配置
  ccs add                    添加新配置
  ccs delete                 删除配置
  ccs edit                   编辑配置
  ccs template               编辑 settings.json 模板
  ccs update                 检查并更新CCS到最新版本
  ccs list                   列出所有配置
  ccs help                   显示此帮助信息

${BOLD}示例:${NC}
  ccs                        # 进入交互式菜单
  ccs production             # 切换到 production 配置
  ccs 1                      # 切换到第1个配置
  ccs add                    # 添加新配置

${BOLD}文件位置:${NC}
  配置目录: ${CLAUDE_DIR}
  配置文件: ${KEYS_FILE}
  设置文件: ${SETTINGS_FILE}
  模板文件: ${TEMPLATE_FILE}
  当前配置: ${CURRENT_FILE}

${BOLD}配置格式:${NC}
  [配置名称]
  baseUrl = https://api.anthropic.com
  apiKey = sk-ant-xxxxx

${BOLD}项目地址:${NC}
  GitHub: ${REPO_URL}
  作者: ${GITHUB_USER}

EOF
}

# =============================================================================
# 主程序
# =============================================================================

main() {
    # 初始化Claude目录
    if ! init_claude_dir; then
        exit 1
    fi
    
    # 检查更新（后台静默进行）
    check_for_updates "$@"
    
    # 解析命令行参数
    case "${1:-}" in
        "")
            interactive_menu
            ;;
        add)
            add_config
            ;;
        delete)
            delete_config
            ;;
        edit)
            edit_config
            ;;
        template)
            edit_template
            ;;
        list)
            list_configs
            ;;
        update)
            force_update "$@"
            ;;
        help|-h|--help)
            show_help
            ;;
        [1-9])
            local configs
            mapfile -t configs < <(get_all_configs)
            if [[ "$1" -le ${#configs[@]} ]]; then
                switch_config "${configs[$((1 - 1))]}"
            else
                print_error "无效的配置编号: $1"
                exit 1
            fi
            ;;
        *)
            # 尝试作为配置名称
            if config_exists "$1"; then
                switch_config "$1"
            else
                print_error "未知命令或配置: $1"
                print_info "使用 'ccs help' 查看帮助信息"
                exit 1
            fi
            ;;
    esac
}

# 运行主程序
main "$@"